DP with memorization...
class Solution {
public:
    int f(int index1 , int index2 , string &s , string &t , vector<vector<int>>& dp)
    {
        if(index2 <= 0 ) return 1;
        if(index1 <= 0 ) return 0;
        if(dp[index1][index2] != -1) return dp[index1][index2];

        if(s[index1-1] == t[index2-1]) 
            return dp[index1][index2] = f(index1-1 , index2-1 , s, t ,dp) + f(index1-1 , index2 , s ,t ,dp);
        else 
            return dp[index1][index2] = f(index1-1 , index2 , s ,t ,dp);
    }
    int numDistinct(string s, string t) {
        int m = s.size();
        int n = t.size();
        vector<vector<int>> dp( m+1 , vector<int>(n+1 , -1));
        return f(m , n , s , t ,dp);
    }
};


DP with tabulation 

class Solution {
public:
    int numDistinct(string s, string t) {
        int m = s.size();
        int n = t.size();
        vector<vector<unsigned long long>> dp( m+1 , vector<unsigned long long>(n+1 , 0));
        for(int i = 0 ;i <= m ;i++)
            dp[i][0] = 1;
        dp[0][0]=1;
        for(int i = 1 ; i<= m ;i++)
        {
            for(int j = 1 ; j<= n ;j++)
            {
                if(s[i-1] == t[j-1])  dp[i][j] = (dp[i-1][j-1] % LLONG_MAX + dp[i-1][j] % LLONG_MAX )% LLONG_MAX;
                else dp[i][j] = dp[i-1][j];
            }
        }
        return dp[m][n];
    }
};

Here we have to use MOdulo operator as the intermediate values go damm high sometimes .
