//PLEASE NOT SUBSET AND SUBARRAY IS DIFFERENT . IN SUBARRAY THE ELEMENTS COME IN THE SAME PARTICULAR ORDER , 
THE NUMBER OF SUBARRAY POSSIBLE FOR A n ELEMENT ARRAY IS n * (n+1) / 2 and not 2^n.

( ğ‘ + ğ‘ ) % ğ‘€ = ( ( ğ‘ % ğ‘€ ) + ( ğ‘ % ğ‘€ ) ) % ğ‘€
( ğ‘ Ã— ğ‘ ) % ğ‘€ = ( ( ğ‘ % ğ‘€ ) Ã— ( ğ‘ % ğ‘€ ) ) % ğ‘€

are the most important rules in the case of modulo operator , keep a note of this to prevent overflow;

///THis is the code i wrote with lot of help from chat gpt , must and should of it again 
class Solution {
public:
int mod = 1000000007;
    int sumSubarrayMins(vector<int>& arr) 
    {
        int len = arr.size();
        stack<pair<int,int>> st;
        vector<int> leftSmaller(len , -1);
        vector<int> rightSmaller(len , len);
        long long sum = 0;
        
        for(int i = arr.size() -1 ;i>=0;i--)
        {
            while(!st.empty() && arr[i]<st.top().first)
                st.pop();
            rightSmaller[i] = st.empty() ? len : st.top().second;
            st.push({arr[i] , i});
        }
        while(!st.empty()) st.pop();
        for( int i = 0;i<len ;i++)
        {
            while(!st.empty() && arr[i]<=st.top().first)
                st.pop();
            leftSmaller[i] = st.empty() ? -1 : st.top().second;
             st.push({arr[i] , i});
        }
        for(int i=0;i<len ; i++)
        {
            long long left =  ( i - leftSmaller[i]) %mod;
            long long right = (rightSmaller[i] - i) % mod ;
            long long prod = (left * right) % mod;
            sum = ((sum +  (prod * arr[i]) % mod) )  % mod; 
        }
        return (int)sum;
    }
};

