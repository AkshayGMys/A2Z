//Did the brute force one very easily
vector<int> output;
        int m = nums1.size();
        int n = nums2.size();
        for(int i=0;i<m;i++)
        {
            int j = 0;
            bool flag = false;
            int next = -1;
            while(j<n && flag == false)
            {
                if(nums2[j] == nums1[i])
                    flag = true;
                j++;
            }
            while(j<n)
            {
                if(nums2[j]>nums1[i])
                {
                    next = nums2[j];
                    break;
                }
                j++;
            }
            output.push_back(next);
        }
        return output;



///Usage of monotonic stack 
I traverse from right and put the biggggg elements in the stack , it the new element i want to put in stack is greater than the element at top , I jsut  remove the elements from stack untill the top element is greater than the one to be inserted and i insert the shit. 
The elements removed will not cause the problem as the inserted element will anyway be bigger than the removed element and will come immidiately to the elements to the left compared to the removed elements 
//AS TRAVERSAL IS REVERSE HERE


class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) 
    {
        stack<int> st;
        unordered_map<int, int> next;

        for (int i = nums2.size() - 1; i >= 0; --i)
        {
            while(!st.empty() && st.top() <=nums2[i])
                st.pop();
                next[nums2[i]] =st.empty() ? -1 : st.top();
            st.push(nums2[i]);
        }

         vector<int> res;
        for (int num : nums1) {
            res.push_back(next[num]);
        }
        return res;
    }
};
