//The problem was if ((mid == 0 || nums[mid] > nums[mid - 1]) && (mid == last || nums[mid] > nums[mid + 1])) 
//I had not checked whether mid could be 0 or last 

I could not even make out this is binary search .
I thought this was not sorted at all.How binary search


If the array ahd only one peak, we can for sure say that the peak is on the left if mid is on the decreasing slope and the peak is on the right if the mid is on the increaing slope .
This works even if the array has multiple peaks .
class Solution {
public:
    int findPeakElement(vector<int>& nums) 
    {
        int left = 0;
        int right = nums.size()-1;
        int mid;

        if(nums.size() ==1 )
            return 0;
         
        if(nums[0]>nums[1])
            return 0;
        if(nums[right]>nums[right-1])
            return right;
        
        left++;
        right--;
        while(left<=right)
        {
            mid = left + (right - left)/2;
            if(nums[mid]>nums[mid+1] && nums[mid]>nums[mid-1])
                return mid;
            else if(nums[mid]<nums[mid-1])
                right = mid-1;
            else
                left = mid+1;
        }
        return -1;
    }
};

