The below one is the brute force solution 

class Solution {
public:
    vector<int> avoidFlood(vector<int>& rains) 
    {
        vector<int> output(rains.size());
        unordered_set<int> uset;
        for(int i=0;i<rains.size();i++)
        {
            if(rains[i]!=0)
            {
                if(uset.find(rains[i])!= uset.end())
                    return {};
                else
                    uset.insert(rains[i]);
                output[i] = -1;
            }
            else
            {
                for(int j=i+1;j<rains.size();j++)
                {
                    if(uset.find(rains[j]) != uset.end())
                    {
                        output[i] = rains[j];
                        uset.erase(rains[j]);
                        break;
                    }
                    else
                        output[i] = -1;     
                }
            }
        }
        return output;
    }
};


THE BELOW IS THE OPTIMAL OUTPUT , I USED HELP FROM CHATGPT TO SOLVE IT 
class Solution {
public:
    vector<int> avoidFlood(vector<int>& rains) 
    {
        int n = rains.size();
        vector<int> result(n,1);
        unordered_map<int,int> lastRained; //Lake and LastRained
        set<int> dryDay;//List of Dry Days in order

        for(int i=0;i<n;i++)
        {
            if(rains[i] == 0)
                dryDay.insert(i);
            else
            {
                int lake = rains[i];
                if(lastRained.find(lake)!= lastRained.end())
                {
                    auto it = dryDay.upper_bound(lastRained[lake]);
                    if(it == dryDay.end()) return {};
                    result[*it] = lake;
                    dryDay.erase(it);
                }
                lastRained[lake] = i;
                result[i] = -1;
            }
        }
        return result;
    }
};
